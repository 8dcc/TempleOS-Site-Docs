"use strict";(self.webpackChunktempleos_simplified=self.webpackChunktempleos_simplified||[]).push([[495],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2964:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={id:"grpaint",title:"Make an Example App",author:"nrootconauto"},o="Making an Example App",l={unversionedId:"holyc/grpaint",id:"holyc/grpaint",title:"Make an Example App",description:"You can make your own apps in TempleOS. Doing so is fun once you get the hang of it,but you will need to get started. In this tutorial,you will learn to make an example program called GrPaint. It's like microsoft paint but for TempleOS.",source:"@site/docs/holyc/make_a_app.mdx",sourceDirName:"holyc",slug:"/holyc/grpaint",permalink:"/holyc/grpaint",tags:[],version:"current",frontMatter:{id:"grpaint",title:"Make an Example App",author:"nrootconauto"},sidebar:"holyc",previous:{title:"Graphics",permalink:"/holyc/graphics"},next:{title:"DolDoc",permalink:"/holyc/doldoc"}},s={},p=[{value:"Setup(Classes 1).",id:"setupclasses-1",level:2},{value:"Macros",id:"macros",level:2},{value:"Setup(Classes 2)",id:"setupclasses-2",level:2},{value:"Setup(Circular Queues)",id:"setupcircular-queues",level:2},{value:"Graphics time",id:"graphics-time",level:2},{value:"User Input",id:"user-input",level:2},{value:"Tool time(Brush)",id:"tool-timebrush",level:2},{value:"Tool Time 2(Fill tool)",id:"tool-time-2fill-tool",level:2},{value:"Tool Time 3(Undo)",id:"tool-time-3undo",level:2},{value:"User Input 2,Menus",id:"user-input-2menus",level:2},{value:"Creating an Epic Background Pattern",id:"creating-an-epic-background-pattern",level:2},{value:"Putting it all Togheter",id:"putting-it-all-togheter",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p};function u(e){let{components:n,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"making-an-example-app"},"Making an Example App"),(0,r.kt)("p",null,"You can make your own apps in TempleOS. Doing so is fun once you get the hang of it,but you will need to get started. In this tutorial,you will learn to make an example program called ",(0,r.kt)("inlineCode",{parentName:"p"},"GrPaint"),". It's like microsoft paint but for TempleOS.\nIn this tutorial,we will learn about:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"User input"),(0,r.kt)("li",{parentName:"ul"},"Graphics,"),(0,r.kt)("li",{parentName:"ul"},"Circular Queues"),(0,r.kt)("li",{parentName:"ul"},"Basic file stuff.\nOk time to rock.")),(0,r.kt)("h2",{id:"setupclasses-1"},"Setup(Classes 1)."),(0,r.kt)("p",null,"In our app,we will define some data structures in a ",(0,r.kt)("inlineCode",{parentName:"p"},"class"),". A class holds data and looks like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"class CName {\n   I64 a,b,c;\n   I64 d,e,f;\n};\n")),(0,r.kt)("p",null,"A class has a name and some members,my main class looks like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"extern class CEditLayer;\nclass CGrPaint {\n//state is the current state(defined later).\n//dft_action is the default action to do(like fill or brush)\n  I64 state,dft_action;\n  I64 w,h;\n  I64 mouse_x;\n  I64 mouse_y;\n//Bit 1 is right\n//Bit 0 is left\n  I64 mouse_buttons;\n  I64 cur_color,cur_thick;\n  I64 _brush_x,_brush_y;\n  CEditLayer *edits;\n  CDC *dc,*picture;\n  U8 *filename;\n} gr_paint;\n//Fill gr_paint will 0's\nMemSet(&gr_paint,0,sizeof(CGrPaint));\n")),(0,r.kt)("p",null,"Sometimes we want to represent something(like the current state) with a number,but it may get tedious to remember the numbers. For this we use..."),(0,r.kt)("h2",{id:"macros"},"Macros"),(0,r.kt)("p",null,"Macros are pieces of text that get inserted into the source code. Here,I to hold the state numbers in a clean way."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"#define PS_NONE 0 //PS means Paint State\n#define PS_BRUSH 1\n#define PS_FILL 2\n#define PS_UNDO 3\n")),(0,r.kt)("p",null,"But you can put any text in a macro. Let's see an example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},'#define TEXT "I love onions"\n"%s\\n",TEXT;\n')),(0,r.kt)("p",null,"Let's define some more macros for our project"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"#define COLOR_BOX_WIDTH 12\n#define SIDE_BAR_WIDTH (5*8)\n#define TOP_BAR_HEIGHT 0\n#define PIC_W (GR_WIDTH-SIDE_BAR_WIDTH)\n#define PIC_H (GR_HEIGHT-TOP_BAR_HEIGHT)\n")),(0,r.kt)("h2",{id:"setupclasses-2"},"Setup(Classes 2)"),(0,r.kt)("p",null,"Sometimes we want to use an existing class as a base type for a new class. We can do this via inheritance. ",(0,r.kt)("strong",{parentName:"p"},"Inheritance will add all the members from a base class to another class"),". It is very epic. Let's see an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"class ABC {\n  I64 a,b,c;\n};\n//Inherited class after ':'\nclass ABCDEF:ABC {\n  I64 d,e,f;\n};\nABC abc;\nabc.a=1;\nabc.b=2;\nabc.c=3;\nABCDEF abcdef;\n//We get 'a' from ABC,and the ABC class starts at the address of abcdef\nabcdef.a=1;\n//..\nabcdef.d=4;\nabcdef.e=5;\nabcdef.f=6;\n")),(0,r.kt)("h2",{id:"setupcircular-queues"},"Setup(Circular Queues)"),(0,r.kt)("p",null,"In our App,I use ",(0,r.kt)("inlineCode",{parentName:"p"},"CQue")," as a base class for our edits,and when we inherit from a base class,we can use the ",(0,r.kt)("strong",{parentName:"p"},"class like the base class via a pointer as the base class gets stored at the start of the new class"),".\nSo let's see some code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"class CEditLayer:CQue {\n  CDC *dc;\n};\nU0 NewUndoLayer() {\n  CEditLayer *new=CAlloc(sizeof CEditLayer); //Allocate memory for new edit\n  //QueInit takes a pointer to CQue,but it is okay to use CEditLayer as it has a base class of CQue\n  QueInit(new);\n  QueIns(new,gr_paint.edits->last);\n  new->dc=DCCopy(gr_paint.picture);\n}\nU0 UndoEnd() {\n  gr_paint.state=PS_NONE;\n}\n")),(0,r.kt)("p",null,"Here we insert the ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," edit into the chain. A circular queue has a head element and it's buddies. ",(0,r.kt)("inlineCode",{parentName:"p"},"gr_paint.edits")," is the head element,and it has a pointer to it's last element in ",(0,r.kt)("inlineCode",{parentName:"p"},"last"),"."),(0,r.kt)("p",null,"When we want to add an item,use ",(0,r.kt)("inlineCode",{parentName:"p"},"QueIns(new,at);"),". Here will use ",(0,r.kt)("inlineCode",{parentName:"p"},"gr_paint.edits->last")," to insert our new edit at the end of the chain."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Wrap around",src:t(5308).Z,width:"1401",height:"657"})),(0,r.kt)("p",null,"But wait,what about undo'ing.. Glad you asked:."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"extern U0 Redraw(Bool bg=FALSE);\nU0 StartUndo() {\n  CEditLayer *edit;\n  if(gr_paint.state!=PS_UNDO) {\n    gr_paint.state=PS_UNDO;\n    edit=gr_paint.edits->last;\n    if(edit!=gr_paint.edits) { //Check if not head element\n      QueRem(edit);\n      DCDel(gr_paint.picture);\n      gr_paint.picture=edit->dc;\n      Free(edit);\n      Redraw(TRUE);\n    }\n  }\n}\n\n//Ignore this,it just ends the undo\nU0 EndUndo() {\n gr_paint.state=PS_NONE;\n}\n")),(0,r.kt)("p",null,"It may be alot to take in,but ill explain. To remove an item from the ",(0,r.kt)("inlineCode",{parentName:"p"},"CQue"),",use ",(0,r.kt)("inlineCode",{parentName:"p"},"QueRem"),". But things get a little tricky here. ",(0,r.kt)("strong",{parentName:"p"},"BE SURE TO NOT DELETE THE HEAD ELEMENT"),". Elements in a ",(0,r.kt)("inlineCode",{parentName:"p"},"CQue")," are ",(0,r.kt)("strong",{parentName:"p"},"Circular"),",meaning the chain loops around.\nSo the ",(0,r.kt)("inlineCode",{parentName:"p"},"gr_paint.edits->last")," will point to the head if the chain is ",(0,r.kt)("em",{parentName:"p"},"empty"),"."),(0,r.kt)("h2",{id:"graphics-time"},"Graphics time"),(0,r.kt)("p",null,"Graphics in TempleOS are very easy to use,we can draw a rectangle to the screen via ",(0,r.kt)("inlineCode",{parentName:"p"},"GrRect"),"(and freinds),but we will first need to specify the color first on the global ",(0,r.kt)("inlineCode",{parentName:"p"},"CDC"),"(known as ",(0,r.kt)("inlineCode",{parentName:"p"},"gr.dc"),")"),(0,r.kt)("p",null,"Lets see an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"gr.dc->color=RED;\nGrRect(gr.dc,0,0,100,100);\nSleep(1000); //Sleep for 1000 milliseconds\nDCFill(gr.dc,TRANSPARENT);\n")),(0,r.kt)("p",null,"Most programs typically have a user interface,so let's draw a color chooser. I will add logic for handling the mouse during this draw routine too,but don't panic as it will be described later"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"I64 DrawColorBar(CDC *dc,I64 x,I64 y) {\n//Draw a grid with the colors\n/*\n This is what it looks like\n  _____\n  | | |\n  | | |\n  =====\n  | | |\n  | | |\n  =====\n   ...\n   ...\n  =====\n*/\n  I64 x2,y2,color=0,bx,by;\n  for(y2=0;y2!=8;y2++) //Loop for each row\n    for(x2=0;x2!=2;x2++) { //Loop for each column\n      dc->thick=2;\n      dc->color=BLACK;\n//Draw border(center will be filled with color later)\n      GrRect(\n        dc,\n        x+x2*COLOR_BOX_WIDTH,\n        y+y2*COLOR_BOX_WIDTH,\n        COLOR_BOX_WIDTH,\n        COLOR_BOX_WIDTH\n      );\n//If mouse is down,we assign the color\n      bx=x+x2*COLOR_BOX_WIDTH+1;\n      by=y+y2*COLOR_BOX_WIDTH+1;\n      //Bt tests if a bit is set,we use it here to check if we are clicking-\n      if(Bt(&gr_paint.mouse_buttons,0))\n        if(bx<=gr_paint.mouse_x<=bx+COLOR_BOX_WIDTH-2)\n          if(by<=gr_paint.mouse_y<=by+COLOR_BOX_WIDTH-2)\n            gr_paint.cur_color=color;\n//Fill in the center\n      dc->color=color++;\n      GrRect(\n        dc,\n        x+x2*COLOR_BOX_WIDTH+1,\n        y+y2*COLOR_BOX_WIDTH+1,\n        COLOR_BOX_WIDTH-2,\n        COLOR_BOX_WIDTH-2\n      );\n    }\n  return y+y2*COLOR_BOX_WIDTH+4;\n}\n")),(0,r.kt)("p",null,"We will need a tools ,And we can draw the tool's name via ",(0,r.kt)("inlineCode",{parentName:"p"},'GrPrint(dc,x,y"text");')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"I64 DrawTool(CDC *dc,I64 x,I64 y,U8 *name,I64 tool) {\n  I64 len=StrLen(name);\n  if(gr_paint.dft_action==tool) {\n    dc->color=BLUE;\n    GrRect(dc,x,y,SIDE_BAR_WIDTH,FONT_HEIGHT);\n    dc->color=RED;\n  } else\n   dc->color=BLACK;\n  GrPrint(dc,x,y,name);\n  if(Bt(&gr_paint.mouse_buttons,0))\n    if(x<=gr_paint.mouse_x<=x+SIDE_BAR_WIDTH)\n      if(y<=gr_paint.mouse_y<=y+FONT_HEIGHT)\n        gr_paint.dft_action=tool;\n  return y+FONT_HEIGHT;\n}\n")),(0,r.kt)("p",null,"Let's throw in both these functions into a function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},'U0 DrawUI(CDC *dc) {\n  I64 y=0;\n  dc->color=WHITE;\n  GrRect(dc,0,0,SIDE_BAR_WIDTH,GR_HEIGHT);\n  dc->color=CYAN;\n  GrPrint(dc,0,0,"Tool"),y+=FONT_HEIGHT;\n  y=DrawColorBar(dc,0,y);\n  y=DrawTool(dc,0,y,"[Pnt]",PS_BRUSH);\n  y=DrawTool(dc,0,y,"[Fll]",PS_FILL);\n}\n')),(0,r.kt)("h2",{id:"user-input"},"User Input"),(0,r.kt)("p",null,"User input in TempleOS is typically handled via events. We can look at events via ",(0,r.kt)("inlineCode",{parentName:"p"},"ScanMsg"),",or if we want keys we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ScanKey(I64 *charactor,I64 *scancode)"),". A scancode is the raw key from the keybaord and the readable charactor.\nLet's see an example of getting user input,but first know that ",(0,r.kt)("strong",{parentName:"p"},"while looping for input you should use ",(0,r.kt)("inlineCode",{parentName:"strong"},"Refresh")," to allow TempleOS to refresh the screen"),". Lets get started"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 InputLoop() {\n  I64 ch,sc;\n  while(TRUE) {\n    if(ScanKey(&ch,&sc)) {\n      if(ch=='Q') {\n        \"Quiting\\n\";\n        break;\n      } else\n       \"Got a '%C'\\n\",ch;\n    }\n    Refresh;\n  }\n}\nInputLoop;\n")),(0,r.kt)("p",null,"Here we only checked for a charactor,but what about ",(0,r.kt)("em",{parentName:"p"},"scancodes"),". Ill explain. A scancode has flags and a unique value. A flag tells you what modifier key is down,like ",(0,r.kt)("inlineCode",{parentName:"p"},"SCF_SHIFT"),",",(0,r.kt)("inlineCode",{parentName:"p"},"SCF_CTRL"),",or ",(0,r.kt)("inlineCode",{parentName:"p"},"SCF_ALT"),". We can can test for a flag by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," operator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"//DONT COPY TTHIS\nU0 InputLoop() {\n  I64 ch,sc;\n  while(TRUE) {\n    if(ScanKey(&ch,&sc)) {\n      if(ch=='Q') {\n        \"Quiting\\n\";\n        break;\n      } else if(!(SCF_SHIFT&sc))\n       \"Got a '%C'(No SHIFT key)\\n\",ch;\n      else\n       \"Got a '%C'(SHIFT key)\\n\",ch;\n\n    }\n    Refresh;\n  }\n}\nInputLoop;\n")),(0,r.kt)("p",null,"You can get the mouse cordnates on a window via ",(0,r.kt)("inlineCode",{parentName:"p"},"ScanMsg"),",or if you want to system mouse cornates you can do ",(0,r.kt)("inlineCode",{parentName:"p"},"ms.pos.x"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"ms.pos.y"),",you can check the buttons via ",(0,r.kt)("inlineCode",{parentName:"p"},"ms.lb"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"ms.rb "),"\nLet's What our input loop looks like."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 GrPaint() {\n   //...\n  while(TRUE) {\n    gr_paint.mouse_x=ms.pos.x;\n    gr_paint.mouse_y=ms.pos.y;\n    BEqu(&gr_paint.mouse_buttons,0,ms.lb);\n    BEqu(&gr_paint.mouse_buttons,1,ms.rb);\n    DrawUI(gr_paint.dc);\n    if(ms.lb) {\n      //..\n    }\n    if(ScanKey(&ch,&sc)) {\n      if(ch==CH_CTRLF) {\n        //...\n      }\n    }\n    //...\n  }\n}\n")),(0,r.kt)("h2",{id:"tool-timebrush"},"Tool time(Brush)"),(0,r.kt)("p",null,"A paint program needs tools. So let's make the most basic tool: ",(0,r.kt)("em",{parentName:"p"},"the brush"),". In our app,we have states,and ",(0,r.kt)("inlineCode",{parentName:"p"},"PS_BRUSH")," is our brush state. We will ",(0,r.kt)("inlineCode",{parentName:"p"},"StartBrushPaint()")," when we start a stroke,and must end the stroke with ",(0,r.kt)("inlineCode",{parentName:"p"},"EndBrushPaint()"),". We will also update the stoke every mouse move with ",(0,r.kt)("inlineCode",{parentName:"p"},"ContinueBrushPaint()"),"."),(0,r.kt)("p",null,"In our ",(0,r.kt)("inlineCode",{parentName:"p"},"StartBrushPaint"),",we make an undo layer ,and then we set the brush cordnates."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 StartBrushPaint() {\n  gr_paint.state=PS_BRUSH;\n  gr_paint._brush_x=gr_paint.mouse_x;\n  gr_paint._brush_y=gr_paint.mouse_y;\n  NewUndoLayer;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ContinueBrushPaint")," will draw a line for the stoke if we have moved the mouse."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 ContinueBrushPaint() {\n  I64 ox=gr_paint._brush_x,oy=gr_paint._brush_y;\n  if(gr_paint.mouse_x!=(ox=gr_paint._brush_x)||\n     gr_paint.mouse_y!=(oy=gr_paint._brush_y)) {\n    gr_paint.picture->thick=gr_paint.cur_thick;\n    gr_paint.picture->color=gr_paint.cur_color;\n    gr_paint._brush_x=gr_paint.mouse_x;\n    gr_paint._brush_y=gr_paint.mouse_y;\n    GrLine3(gr_paint.picture,ox,oy,0,gr_paint._brush_x,gr_paint._brush_y,0);\n  }\n  Redraw;\n}\n")),(0,r.kt)("p",null,"Here we used ",(0,r.kt)("inlineCode",{parentName:"p"},"GrLine3")," to do some epic line drawing. We can we set the thickness and color with ",(0,r.kt)("inlineCode",{parentName:"p"},"CDC.cur_color")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CDC.thick"),"."),(0,r.kt)("p",null,"And finaly we end the state via"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 EndBrushPaint() {\n  gr_paint.state=PS_NONE;\n}\n")),(0,r.kt)("h2",{id:"tool-time-2fill-tool"},"Tool Time 2(Fill tool)"),(0,r.kt)("p",null,"This tool is pretty easy,use ",(0,r.kt)("inlineCode",{parentName:"p"},"GrFloodFill"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 FillToolStart() {\n  NewUndoLayer;\n  gr_paint.state=PS_FILL;\n  gr_paint.picture->color=gr_paint.cur_color;\n  GrFloodFill(gr_paint.picture,gr_paint.mouse_x,gr_paint.mouse_y);\n  Redraw;\n}\nU0 FillToolEnd() {\n   gr_paint.state=PS_NONE;\n}\n")),(0,r.kt)("h2",{id:"tool-time-3undo"},"Tool Time 3(Undo)"),(0,r.kt)("p",null,"See the code from ",(0,r.kt)("a",{parentName:"p",href:"#Setup(Circular-Queues)"},"Setup(Circular-Queues)")),(0,r.kt)("h2",{id:"user-input-2menus"},"User Input 2,Menus"),(0,r.kt)("p",null,"TempleOS has a menu system. You can hold down the logo key to access the menu and it looks something like this:\n",(0,r.kt)("a",{parentName:"p",href:"todo.jpeg"},"img")),(0,r.kt)("p",null,"We can push a menu to TempleOS with ",(0,r.kt)("inlineCode",{parentName:"p"},"MenuPush"),". But first we need to know how menus work. Menus work by sending events to the current task. These messages are ",(0,r.kt)("inlineCode",{parentName:"p"},"MSG_KEY_DOWN"),",and the arguments are the charactor and scancode. Let's see an example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},'U0 MenuLoop() {\n  I64 ch;\n  MenuPush(\n    "File {"\n//1st is message(Default is MSG_KEY_DOWN)\n//2nd is charctor\n//3rd is scancode\n    "  Exit(,CH_SHIFT_ESC,);"\n    "}"\n    "Fruit {"\n    "    Apple(,\'apple\',);"\n    "    Banana(,\'banana\',);"\n    "    Berry(,\'berry\',);"\n    "}"\n    "Vegetable {"\n    "    Carrot(,\'carrot\',);"\n    "    Celery(,\'celery\',);"\n    "}"\n  );\n  "Access stuff from the menu!!\\n";\n  while(ch=GetKey) {\n    if(ch==CH_SHIFT_ESC) break;\n    "Got a %c\\n",ch;\n  }\n  MenuPop;\n}\nMenuLoop;\n')),(0,r.kt)("p",null,"Let's look at our init code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},'U0 Init() {\n  gr_paint.edits=CAlloc(sizeof(CQue));\n  gr_paint.dc=gr.dc;\n  gr_paint.picture=DCNew(GR_WIDTH,GR_HEIGHT);\n  QueInit(gr_paint.edits);\n  //Fill with transparent\n  DCFill(gr_paint.dc);\n  DCFill(gr_paint.picture);\n  WinBorder;\n  WinMax;\n  MenuPush(\n    "File {"\n    "    Save(,CH_CTRLS,);"\n    "    Exit(,CH_ESC,);"\n    "    Abort(,CH_SHIFT_ESC,);"\n    "}"\n    "Edit {"\n    "    Brush(,CH_CTRLB,);"\n    "    Fill(,CH_CTRLF,);"\n    "}"\n  );\n}\n')),(0,r.kt)("h2",{id:"creating-an-epic-background-pattern"},"Creating an Epic Background Pattern"),(0,r.kt)("p",null,"Our backround could be all white,but that wouldn't be too fun,so I will make a checkerboard pattern. A key aspect of this pattern is switching the color on and off. Luckily computers can do this via a bitwise operator. This operator is called an XOR operator and looks like this in HolyC ",(0,r.kt)("inlineCode",{parentName:"p"},"^"),"."),(0,r.kt)("p",null,"An XOR operator will toggle the other bit if a bit is set. Let's see it in table form:\n|A|B|Result|\n|--|--|--|\n|1|1|0|\n|1|0|1|\n|0|1|1|\n|0|0|0|\nHere,I XOR with 1,and by doing so the value will turn off or on,let's see the nlock"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 DrawCheckers(CDC *dc,I64 x,I64 y,I64 w,I64 h) {\n#define CHECKER_WIDTH 14\n  //Draw a checker board pettern\n  I64 blink=FALSE,blink2=FALSE;\n  I64 color;\n  I64 x2,y2;\n  for(x2=x;x2<x+w;x2+=CHECKER_WIDTH) {\n    //XORing toggles a bit,so we XOR with TRUE to toggle it\n    blink=blink2^=TRUE;\n    for(y2=y;y2<w+h;y2+=CHECKER_WIDTH) {\n      if(blink)\n        blink=FALSE,color=LTGRAY;\n      else\n        blink=TRUE,color=WHITE;\n      dc->color=color;\n      GrRect(dc,x2,y2,CHECKER_WIDTH,CHECKER_WIDTH);\n    }\n  }\n}\n")),(0,r.kt)("h2",{id:"putting-it-all-togheter"},"Putting it all Togheter"),(0,r.kt)("p",null,"We will need to be able save the file. Luckily for us we can save a ",(0,r.kt)("inlineCode",{parentName:"p"},"CDC")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"GRWrite(filename,dc);")," but we will need get a filename first. We can get a pop-up window with ",(0,r.kt)("inlineCode",{parentName:"p"},"PopUpFileName(default);\x05"),". Will will need to clear the graphics off the screen so we can look at the window first,so we ",(0,r.kt)("inlineCode",{parentName:"p"},"DCFill")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},'extern CDC *AutoCrop(CDC *img);\nU0 SaveFileAs(Bool prompt=TRUE) {\n  CDC *dc;\n  if(prompt)\n    Free(gr_paint.filename);\n  DCFill;\n  if(prompt||!gr_paint.filename)\n  gr_paint.filename=PopUpFileName("DRAWING.GR");\n  //We will define AutoCrop later\n  dc=AutoCrop(gr_paint.picture);\n  if(gr_paint.filename)\n    GRWrite(gr_paint.filename,dc);\n  DCDel(dc);\n  Redraw(TRUE);\n}\n')),(0,r.kt)("p",null,"It would be strange to save the area around the image,so we will make a function to crop the image for us. Here will will use ",(0,r.kt)("inlineCode",{parentName:"p"},"GrPeek0")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GrPlot0"),". These do not apply transformations and are relativly fast."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"CDC *AutoCrop(CDC *img) {\n  I64 x,y,top=-1,left=-1,bottom=I64_MIN,right=I64_MIN;\n  CDC *dc;\n  for(x=SIDE_BAR_WIDTH;x!=PIC_W;x++) //Image includes sidebar\n    for(y=0;y!=PIC_H;y++) {\n     if(top==-1||y<top)\n       if(GrPeek0(img,x,y)!=TRANSPARENT)\n        top=y;\n     if(left==-1||x<left)\n       if(GrPeek0(img,x,y)!=TRANSPARENT)\n        left=x;\n     if(GrPeek0(img,x,y)!=TRANSPARENT)\n       if(right<x)\n         right=x;\n     if(GrPeek0(img,x,y)!=TRANSPARENT)\n       if(bottom<y)\n         bottom=y;\n    }\n  if(top==-1||left==-1)\n    return DCNew(0,0);\n  dc=DCNew(right-left+1,bottom-top+1,);\n  for(x=left;x!=right+1;x++)\n    for(y=top;y!=bottom+1;y++) {\n      dc->color=GrPeek0(img,x,y);\n      GrPlot0(dc,x-left,y-top);\n    }\n  return dc;\n}\n")),(0,r.kt)("p",null,"Sometimes we need to repaint the screen,so let's do that"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 FastPutPicture(CDC *picture) {\n  I64 p;\n  for(p=0;p!=GR_WIDTH*GR_HEIGHT;p++) {\n    if(picture->body[p]!=TRANSPARENT)\n      gr.dc->body[p]=picture->body[p];\n  }\n}\nU0 Redraw(Bool bg=FALSE) {\n  if(bg)\n    DrawCheckers(gr_paint.dc,SIDE_BAR_WIDTH,0,PIC_W,PIC_H);\n  FastPutPicture(gr_paint.picture);\n  DrawUI(gr_paint.dc);\n}\n")),(0,r.kt)("p",null,"We should cleanup when we exit the program. Each TempleOS ",(0,r.kt)("inlineCode",{parentName:"p"},"CTask")," has a ",(0,r.kt)("inlineCode",{parentName:"p"},"task_end_cb"),",which takes a fun ction address which will can get via the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," operator. Fs points to the current ",(0,r.kt)("inlineCode",{parentName:"p"},"CTask")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 DeInit() {\n  MenuPop;\n  DCFill(gr.dc);\n}\nU0 GrPaintExit() {\n  Exit;\n}\n//We will put this in the GrPaint function later\n//Fs->task_end_cb=&DeInit;\n")),(0,r.kt)("p",null,"And finally we need the ",(0,r.kt)("inlineCode",{parentName:"p"},"GrPaint")," logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"U0 GrPaint() {\n  I64 x,y,res,ch,sc;\n  CEditLayer *edit;\n  AutoComplete;\n  Init;\n  gr_paint.dft_action=PS_BRUSH;\n  Fs->task_end_cb=&DeInit;\n  gr_paint.cur_thick=10;\n  Redraw(TRUE);\n  while(TRUE) {\n    gr_paint.mouse_x=ms.pos.x;\n    gr_paint.mouse_y=ms.pos.y;\n    BEqu(&gr_paint.mouse_buttons,0,ms.lb);\n    BEqu(&gr_paint.mouse_buttons,1,ms.rb);\n    DrawUI(gr_paint.dc);\n    if(ms.lb) {\n      //Left click\n      switch(gr_paint.state) {\n        case PS_NONE:\n          //Only activate if we are in the drawing area\n          if(SIDE_BAR_WIDTH<=gr_paint.mouse_x<=GR_WIDTH)\n            if(TOP_BAR_HEIGHT<=gr_paint.mouse_y<=GR_HEIGHT) {\n              gr_paint.state=PS_BRUSH;\n              switch(gr_paint.dft_action) {\n              case PS_BRUSH:\n                StartBrushPaint;\n                goto next;\n              case PS_FILL:\n                FillToolStart;\n                goto next;;\n              }\n            }\n          break;\n        case PS_FILL:\n          //We go to the next as we haven't release the left click yet\n          goto next;\n        case PS_BRUSH:\n          ContinueBrushPaint;\n          goto next;\n        default:\n         goto end_state;\n      }\n    } else {\n      //Left button is up\n      switch(gr_paint.state) {\n        case PS_BRUSH:\n        case PS_FILL:\n          goto end_state;\n      }\n    }\n    if(ScanKey(&ch,&sc)) {\n      if(ch==CH_CTRLF) {\n        gr_paint.dft_action=PS_FILL;\n        goto end_state;\n      }\n      if(ch==CH_CTRLU) {\n         if(gr_paint.state==PS_NONE) {\n           StartUndo;\n          goto next;\n         } else if(gr_paint.state==PS_UNDO) {\n           //If we hold 'u' down,be sure to not undo again to avoid repatingly undoing your work\n           goto next;\n         } else goto end_state;\n      }\n      if(ch==CH_CTRLS) {\n        SaveFileAs(FALSE);\n        goto next;\n      }\n      if(ch==CH_CTRLB) {\n        gr_paint.dft_action=PS_BRUSH;\n        goto end_state;\n      }\n      if(ch==CH_ESC) {\n        SaveFileAs(FALSE);\n        break;\n      }\n      if(ch==CH_SHIFT_ESC) {\n        break;\n      }\n    }\n//Undo is triggered by button,so if no\nend_state:\n      switch(gr_paint.state) {\n        case PS_NONE:\n          break;\n        case PS_BRUSH:\n          EndBrushPaint;\n          break;\n        case PS_FILL:\n          FillToolEnd;\n          break;\n        case PS_UNDO:\n          UndoEnd;\n          break;\n      }\nnext:\n    Refresh;\n  }\n  GrPaintExit;\n}\n")),(0,r.kt)("p",null,"Be sure to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"GrPaint")," function at the end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},"GrPaint;\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Painting",src:t(9946).Z,width:"1004",height:"710"})),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Writing an app in TempleOS can be difficult at the start,but it get's easier as you go along. And now you even have a means of creating ",(0,r.kt)("inlineCode",{parentName:"p"},".GR")," files for your games\nIf you want to view an Image,do"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-holyc"},'//DocPut is the current document\nDocGR(DocPut,"DRAWING.GR");\n')))}u.isMDXComponent=!0},5308:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/cque_wrap_around-d042e81d3909c223c0479758ff6c46c9.png"},9946:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/painting-6057ab1cdf77d986a29207905cb2ec14.jpg"}}]);