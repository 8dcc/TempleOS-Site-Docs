"use strict";(self.webpackChunktempleos_simplified=self.webpackChunktempleos_simplified||[]).push([[983],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=i,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return t?a.createElement(k,r(r({ref:n},c),{},{components:t})):a.createElement(k,r({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},986:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const o={id:"multic",title:"Multi-Threading"},r="Multi-Threading",l={unversionedId:"holyc/multic",id:"holyc/multic",title:"Multi-Threading",description:"Introduction",source:"@site/docs/holyc/multi_thread.mdx",sourceDirName:"holyc",slug:"/holyc/multic",permalink:"/holyc/multic",tags:[],version:"current",frontMatter:{id:"multic",title:"Multi-Threading"},sidebar:"holyc",previous:{title:"User Input",permalink:"/holyc/input"},next:{title:"Make an Example App",permalink:"/holyc/grpaint"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Yielding",id:"yielding",level:2},{value:"Killing Tasks and Cleanup",id:"killing-tasks-and-cleanup",level:2},{value:"Spin-Locks and Sharing Data across Cores",id:"spin-locks-and-sharing-data-across-cores",level:2},{value:"Task Communication",id:"task-communication",level:2},{value:"Talking to Yourself",id:"talking-to-yourself",level:3}],c={toc:p};function u(e){let{components:n,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"multi-threading"},"Multi-Threading"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In TempleOS,you can spawn multiple task's. These are called thread's in other\noperating systems. Each CPU core has it's own Task(only 1 task runs on each\ncore at once). Because of this, ",(0,i.kt)("strong",{parentName:"p"},"you must ",(0,i.kt)("inlineCode",{parentName:"strong"},"Yield")," to tell TempleOS to go\nto the next task"),". If you don't ",(0,i.kt)("inlineCode",{parentName:"p"},"Yield"),"(or use it's friends) you will freeze,but don't worry,you can tell TempleOS to wake up by pressing ",(0,i.kt)("inlineCode",{parentName:"p"},"Ctrl+Alt+C"),". This will send a ",(0,i.kt)("inlineCode",{parentName:"p"},"Break")," exception to the current ",(0,i.kt)("inlineCode",{parentName:"p"},"CTask"),"(unless ",(0,i.kt)("inlineCode",{parentName:"p"},"BreakLock(TRUE)"),") was called. Enough talk,let's example it out "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'U0 FunTask(\n    //MUST TAKE A SINGLE ARGUMENT\n    I64 dummy\n) {\n  //Decrease dummy by 1 each time,until lesser than 0\n  while(--dummy>=0)\n    Play("EGBDF#");\n}\nCTask *task=Spawn(\n  &FunTask, //& get\'s the address of FunTask\n  2, //Argument to function\n  "Task Name",\n);\n//Wait for task to be born\nBirthWait(&task);\n"BORN... WAITING FOR EXIT\\n";\n//Wait for it to be done\nDeathWait(&task);\n"task DIED\\n";\n')),(0,i.kt)("p",null,"We have lot's to unpack here. ",(0,i.kt)("inlineCode",{parentName:"p"},"Spawn")," Queues a new ",(0,i.kt)("inlineCode",{parentName:"p"},"CTask")," in on a core. ",(0,i.kt)("inlineCode",{parentName:"p"},"BirthWait(CTask **)")," waits for a ",(0,i.kt)("inlineCode",{parentName:"p"},"CTask")," to be born,and ",(0,i.kt)("inlineCode",{parentName:"p"},"DeathWait(CTask **)")," waits for a ",(0,i.kt)("inlineCode",{parentName:"p"},"CTask")," to finish."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Purpose"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Spawn(fun_ptr,argument,name,target_cpu,parent)"),(0,i.kt)("td",{parentName:"tr",align:null},"Spawn a task that runs ",(0,i.kt)("inlineCode",{parentName:"td"},"fun_ptr")," on ",(0,i.kt)("inlineCode",{parentName:"td"},"target_cpu"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BirthWait(CTask **)"),(0,i.kt)("td",{parentName:"tr",align:null},"Takes a pointer to a ",(0,i.kt)("inlineCode",{parentName:"td"},"CTask*"),",waits for a ",(0,i.kt)("inlineCode",{parentName:"td"},"CTask*")," to be born.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"DeathWait(CTask **)"),(0,i.kt)("td",{parentName:"tr",align:null},"Wait's for a ",(0,i.kt)("inlineCode",{parentName:"td"},"CTask")," to return or ",(0,i.kt)("inlineCode",{parentName:"td"},"Exit"),".")))),(0,i.kt)("h2",{id:"yielding"},"Yielding"),(0,i.kt)("p",null,"Let's say you have a task that uses much CPU. You need to ",(0,i.kt)("inlineCode",{parentName:"p"},"Yield")," to give up control for a bit . Let's do an 2 expensive operations (one with  ",(0,i.kt)("inlineCode",{parentName:"p"},"Yield")," and one without)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'\n//\n// DocPut get\'s the document of the current task (which \n// is what you see on the screen right now).\n//\nCDoc *print_to=DocPut; \nI64 ExpensiveNoYield(I64 fib) {\n  if(fib<2) return fib;\n  return ExpensiveNoYield(fib-1)+\n     ExpensiveNoYield(fib-2);\n}\nU0 RunnerNoYield(I64 value) {\n  F64 start=tS;\n  DocPrint(print_to,"FIB(%d)==%d\\n",value,ExpensiveNoYield(value));\n  DocPrint(print_to,"It took  %n seconds\\n",tS-start);\n}\nI64 ExpensiveYield(I64 fib) {\n  static I64 cnt;\n  //Yield every 100 calls\n  cnt++;\n  if(cnt>100) {\n    Yield;\n    cnt=0;\n  }\n\n\n  if(fib<2) {\n    return fib;\n  }\n  return ExpensiveYield(fib-1)+\n     ExpensiveYield(fib-2);\n}\nU0 RunnerYield(I64 value) {\n  F64 start=tS;\n  DocPrint(print_to,"FIB(%d)==%d\\n",value,ExpensiveYield(value));\n  DocPrint(print_to,"It took  %n seconds\\n",tS-start);\n}\n"Expensive without Yield\'ing\\n";\nCTask *ny=Spawn(&RunnerNoYield,40);\nDeathWait(&ny);\n"Expensive with Yield\'ing\\n";\nCTask *y=Spawn(&RunnerYield,40);\nDeathWait(&y);\n')),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Yielding time results",src:t(1600).Z,width:"578",height:"132"})),(0,i.kt)("p",null,"As you can see,Not-",(0,i.kt)("inlineCode",{parentName:"p"},"Yield"),'ing will "freeze" the CPU for a bit,but ',(0,i.kt)("inlineCode",{parentName:"p"},"Yield"),"ing. ",(0,i.kt)("inlineCode",{parentName:"p"},"Yield")," will let the CPU  do other tasks for a bit hence it takes a bit more time."),(0,i.kt)("h2",{id:"killing-tasks-and-cleanup"},"Killing Tasks and Cleanup"),(0,i.kt)("p",null,"You can kill a task in TempleOS via ",(0,i.kt)("inlineCode",{parentName:"p"},"Kill"),". You may want have the killed task do some cleanup. TempleOS gives us a ",(0,i.kt)("inlineCode",{parentName:"p"},"task_end_cb")," which is run when a task is about to die. In  the following example,the ",(0,i.kt)("inlineCode",{parentName:"p"},"AnnoyingSong")," task will be stop playing the sound when it is killed when ",(0,i.kt)("inlineCode",{parentName:"p"},"SndTaskEndCB")," is called at the end"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'U0 AnnoyingSong(I64 dummy) {\n//This is called on Exit or otherwise dies\n  Fs->task_end_cb=&SndTaskEndCB;\n  while(TRUE) {\n    Play("EGGE#GG#");\n  }\n}\nCTask *t=Spawn(&AnnoyingSong);\n//Sleep for 3000 milliseconds\nSleep(3000);\n"KILLING t\\n";\nKill(t);\n"FINALLY\\n";\n')),(0,i.kt)("p",null,"You can make your own ",(0,i.kt)("inlineCode",{parentName:"p"},"task_end_cb")," like this"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'U0 EndCb() {\n  Snd; //Turn off sound\n  Exit; //Exit the task\n}\nU0 AnnoyingSong(I64 dummy) {\n//This is called on Exit or otherwise dies\n  Fs->task_end_cb=&EndCb;\n  while(TRUE) {\n    Play("EGGE#GG#");\n  }\n}\nCTask *t=Spawn(&AnnoyingSong);\n//Sleep for 3000 milliseconds\nSleep(3000);\n"KILLING t\\n";\nKill(t);\n"FINALLY\\n";\n')),(0,i.kt)("h2",{id:"spin-locks-and-sharing-data-across-cores"},"Spin-Locks and Sharing Data across Cores"),(0,i.kt)("p",null,"In TempleOS,you are only limited by your imagination(and your number of cores). You can get the core count with ",(0,i.kt)("inlineCode",{parentName:"p"},"mp_cnt"),",and the current core number with ",(0,i.kt)("inlineCode",{parentName:"p"},"Gs->num"),". When you use multiple cores,",(0,i.kt)("strong",{parentName:"p"},"you must be careful to make sure each core has a lock on the data because something called a race condition may happen"),". A race condition is when 2 or more cores try to access the same stuff at once. Imagine lots of people trying to access a vending machine at once,the vending machine wouldn't know who gets what."),(0,i.kt)("p",null,"To resolve the vending machine issue we use a lock(a spin-lock to be exact). A spin lock will spin until everyone is done with it or no one is using it. At the same time,",(0,i.kt)("strong",{parentName:"p"},"LBts will set the bit and return the old value in one instruction so there is no race condition"),". This will set the bit telling other people that the vending machine is being used and that they have to wait. Perhaps an example will help:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'//\n// We set bit 0 of spin_lock to tell the\n// cores that some_string is being used. \n// This way the cores who OWN\'s some_string\n//\n// If we didn\'t do this another core could modify\n// some_string\'s data and things could messy\n//\nI64 spin_lock=0;\nU8 *some_string=NULL;\nCDoc *doc=DocPut;\n\nI64 done_flags=0;\nU0 PrintName(I64) {\n//\n// We set bit 0 to tell the cores we are locked\n// We reset bit 0 to tell to tell the core the spin_lock is availble\n//\n\n//Lock set bit 0,returns old value\n  while(LBts(&spin_lock,0))\n    Yield;\n\n//\n// Gs->num has the current core number\n//\n  some_string=MStrPrint("I am from core %d",Gs->num);\n  DocPrint(doc,"%s\\n",some_string);\n//Set the done\n  LBts(&spin_lock,Gs->num); //Gs->num is core number\n//Locked reset bit 0\n  LBtr(&spin_lock,0);\n}\n\n//\n// mp_cnt is the Number of cores in your system\n//\nI64 core;\nfor(core=0;core!=mp_cnt;core++) {\n  Spawn(&PrintName,NULL,"PrintName",core);\n}\n//Wait for all done_flags  to be set\nfor(core=0;core!=mp_cnt;core++) {\n  if(!Bt(&done_flags,core))\n    Yield;\n}\n"ALL-DONE\\n";\n')),(0,i.kt)("p",null,"Here we locked ",(0,i.kt)("inlineCode",{parentName:"p"},"&spin_lock")," by ",(0,i.kt)("strong",{parentName:"p"},"atomically")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"LBts(ptr,bit)"),". This means the computer will automatically acquire the ptr and set and return the bit's value in 1 instruction. This is useful as we can check and acquire lock at once. We also use ",(0,i.kt)("inlineCode",{parentName:"p"},"LBts")," to set ",(0,i.kt)("inlineCode",{parentName:"p"},"Gs->num")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"done_flags"),",which will check to see when all the cores are finished. We ",(0,i.kt)("inlineCode",{parentName:"p"},"Yield")," while ",(0,i.kt)("inlineCode",{parentName:"p"},"LBts")," returns 1(The bit is set after the internal check for if it is previously 0)"),(0,i.kt)("h2",{id:"task-communication"},"Task Communication"),(0,i.kt)("p",null,"These is a special kind of task which runs ",(0,i.kt)("inlineCode",{parentName:"p"},"SrvTaskCont")," (which you create using ",(0,i.kt)("inlineCode",{parentName:"p"},"Spawn"),"). This task will run jobs for you which you can send via ",(0,i.kt)("inlineCode",{parentName:"p"},"TaskExe(server,parent,text,flags)"),". When the job completes you can get the result via ",(0,i.kt)("inlineCode",{parentName:"p"},"JobResGet(CJob *)"),".  Here is an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'CTask *server=Spawn(&SrvTaskCont);\n//Final statement is 1+3,so result will be 4\nCJob *job=TaskExe(server,Fs,"Beep;1+3;",0);\n"Result is %d\\n",JobResGet(job);\nKill(server);\n')),(0,i.kt)("p",null,"If you just want to run a job and have it complete,there is a flag to suspend the master and then un-freeze it when the job completes . "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'CTask *server=Spawn(&SrvTaskCont);\n//This job will freeze the current task(Fs) and will unfreeze it after the Beep.\nCJob *job=TaskExe(server,Fs,"Beep;",1<<JOBf_WAKE_MASTER);\nKill(server);\nExit;\n')),(0,i.kt)("h3",{id:"talking-to-yourself"},"Talking to Yourself"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Fs")," is a function that returns the current task,and you can use it to make the task send input to itself(You can do this via ",(0,i.kt)("inlineCode",{parentName:"p"},"XTalk(Fs,fmt,...);"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'XTalk(Fs,"I got input!!!");\n')),(0,i.kt)("p",null,"You can even talk to other user Terminals spawned by ",(0,i.kt)("inlineCode",{parentName:"p"},"User"),";"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-holyc"},'CTask *t=User;\nXTalk(t,"1+2;\\n");\n')))}u.isMDXComponent=!0},1600:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/yield_time-9c74e2c7a830682a5314d5b4493bc655.png"}}]);